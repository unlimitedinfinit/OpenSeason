use std::path::PathBuf;
use typst::diag::{FileError, FileResult, SourceResult};
use typst::foundations::{Bytes, Datetime, Smart};
use typst::syntax::{FileId, Source, VirtualPath};
use typst::text::{Font, FontBook};
use typst::Library;
use typst::World;
use typst::utils::LazyHash; // Typst 0.12 wrapper
use typst_pdf::{PdfOptions, PdfStandards};
use chrono::{Datelike, Timelike};

// MinimalWorld Implementation
pub struct MinimalWorld {
    library: LazyHash<Library>,
    book: LazyHash<FontBook>,
    fonts: Vec<Font>,
    source: Source,
    now: Datetime,
}

impl MinimalWorld {
    pub fn new(source_text: String) -> Self {
        // Cross-platform font loading
        let mut fonts = Vec::new();
        
        let font_search_paths = [
            // Windows
            "C:\\Windows\\Fonts\\arial.ttf",
            "C:\\Windows\\Fonts\\calibri.ttf",
            "C:\\Windows\\Fonts\\seguiemj.ttf",
            // macOS
            "/Library/Fonts/Arial.ttf",
            "/System/Library/Fonts/Helvetica.ttc",
            "/System/Library/Fonts/Supplemental/Arial.ttf",
            // Linux
            "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
            "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
            "/usr/share/fonts/gnu-free/FreeSans.ttf"
        ];

        let mut found_any = false;

        for path in font_search_paths {
             if let Ok(data) = std::fs::read(path) {
                 let buffer = Bytes::from(data);
                 for index in 0..10 {
                     match Font::new(buffer.clone(), index) {
                         Some(font) => {
                             fonts.push(font);
                             found_any = true;
                         },
                         None => break,
                     }
                 }
             }
        }

        if !found_any {
            eprintln!("WARNING: No system fonts found. PDF generation may fail.");
        }
        
        let book = FontBook::from_fonts(&fonts);
        let library = Library::builder().build();
        
        // Construct Datetime from Chrono
        let now_chrono = chrono::Local::now();
        let now = Datetime::from_ymd_hms(
            now_chrono.year(),
            now_chrono.month() as u8,
            now_chrono.day() as u8,
            now_chrono.hour() as u8,
            now_chrono.minute() as u8,
            now_chrono.second() as u8,
        ).unwrap_or(Datetime::from_ymd(1970, 1, 1).unwrap());

        Self {
            library: LazyHash::new(library),
            book: LazyHash::new(book),
            fonts,
            source: Source::detached(source_text),
            now,
        }
    }
}

impl World for MinimalWorld {
    fn library(&self) -> &LazyHash<Library> {
        &self.library
    }

    fn book(&self) -> &LazyHash<FontBook> {
        &self.book
    }

    fn main(&self) -> FileId {
        self.source.id()
    }

    fn source(&self, id: FileId) -> FileResult<Source> {
        if id == self.source.id() {
            Ok(self.source.clone())
        } else {
            Err(FileError::NotFound(PathBuf::from(id.vpath().as_rooted_path())))
        }
    }

    fn file(&self, _id: FileId) -> FileResult<Bytes> {
        Err(FileError::NotFound(PathBuf::new()))
    }

    fn font(&self, index: usize) -> Option<Font> {
        self.fonts.get(index).cloned()
    }

    fn today(&self, _offset: Option<i64>) -> Option<Datetime> {
        Some(self.now)
    }
}

pub fn compile_report(
    target_name: &str, 
    evidence_count: usize,
    total_value: f64
) -> Result<Vec<u8>, String> {
    // 1. Create Typst Template String
    let template = format!(
        r#"
#set page(paper: "us-letter", margin: 1in)
#set text(font: "Arial", size: 11pt)

#align(center)[
  #text(size: 16pt, weight: "bold")[DISCLOSURE STATEMENT]
  #v(0.5em)
  #text(size: 12pt)[CONFIDENTIAL -- ATTORNEY WORK PRODUCT]
]

#v(2em)

*TO:* United States Department of Justice\
*FROM:* Relator (Anonymous)\
*DATE:* {date}

*RE:* Violations of the False Claims Act by {target}

= I. Summary
Relator submits this disclosure statement pursuant to 31 U.S.C. 3730(b)(2). The evidence enclosed herein demonstrates that {target} has knowingly presented false or fraudulent claims for payment to the United States Government.

= II. Target Information
- **Entity Name:** {target}
- **Identified Contracts Value:** \${value}

= III. Evidence Log
The Relator has secured {count} distinct pieces of evidence, including encrypted documents and data snapshots.

#table(columns: (auto, 1fr), inset: 10pt, align: horizon, [*ID*], [*Description*], [001], [Primary Contract Vehicle Audit], [002], [Communication Log: Billing Irregularities], [...], [Additional Encrypted Assets in Bundle])

#v(2fr)
_Generated by Open Season Toolkit_
"#,
        target = target_name,
        date = chrono::Local::now().format("%Y-%m-%d"),
        count = evidence_count,
        value = total_value
    );

    // 2. Initialize World
    let world = MinimalWorld::new(template);

    // 3. Compile (No tracer in 0.12)
    // The result is Warned<SourceResult<Document>>. We need .output which is SourceResult<Document>.
    let warned = typst::compile(&world);
    
    match warned.output {
        Ok(document) => {
            let options = PdfOptions {
                ident: Smart::Auto,
                timestamp: Some(world.now),
                page_ranges: None,
                standards: PdfStandards::default(),
                // 'tagged' field removed in 0.12? User says so.
            };
            
            // Typst PDF 0.12 signature: pdf(&Document, &PdfOptions) -> SourceResult<Vec<u8>>
            match typst_pdf::pdf(&document, &options) {
                Ok(bytes) => Ok(bytes),
                Err(errors) => Err(format!("PDF Generation Error: {:?}", errors))
            }
        },
        Err(errors) => {
            let msg = errors.iter()
                .map(|e| e.message.to_string())
                .collect::<Vec<_>>()
                .join("\n");
            Err(format!("Compilation Error: {}", msg))
        }
    }
}
